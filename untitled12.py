# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w3cJxexeR9-AJDh1__y-nqfAOoPTmPHG
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import torch
import torch.nn as nn
from sklearn.preprocessing import StandardScaler
from statsmodels.tsa.statespace.sarimax import SARIMAX
import streamlit as st
import warnings
warnings.filterwarnings("ignore")

def generate_synthetic_data(n=1500):
    t = np.arange(n)
    seasonal = 10 * np.sin(2 * np.pi * t / 50)
    trend = 0.02 * t
    noise = np.random.normal(0, 2, n)
    val0 = trend + seasonal + noise
    val1 = 0.5 * val0 + np.random.normal(0, 1, n)
    val2 = -0.3 * val0 + np.random.normal(0, 1, n)

    df = pd.DataFrame({
        "date": pd.date_range(start="2020-01-01", periods=n, freq="D"),
        "value_0": val0,
        "value_1": val1,
        "value_2": val2
    })
    df.set_index("date", inplace=True)
    return df


df = generate_synthetic_data()
df.to_csv("synthetic_data.csv")

scaler = StandardScaler()
scaled = scaler.fit_transform(df)
features = df.columns.tolist()

def create_sequences(data, seq_len, forecast_len):
    X, Y = [], []
    for i in range(len(data) - seq_len - forecast_len):
        X.append(data[i:i+seq_len])
        Y.append(data[i+seq_len:i+seq_len+forecast_len, 0])
    return np.array(X), np.array(Y)

seq_len = 60
forecast_len = 14

X, Y = create_sequences(scaled, seq_len, forecast_len)
X_t = torch.tensor(X).float()
Y_t = torch.tensor(Y).float().unsqueeze(-1)

class TransformerTS(nn.Module):
    def __init__(self, n_features=3, d_model=64, n_heads=4, num_layers=2, forecast_len=14):
        super().__init__()
        self.input_proj = nn.Linear(n_features, d_model)

        encoder_layer = nn.TransformerEncoderLayer(
            d_model=d_model, nhead=n_heads, batch_first=True
        )
        self.encoder = nn.TransformerEncoder(encoder_layer, num_layers=num_layers)

        decoder_layer = nn.TransformerDecoderLayer(
            d_model=d_model, nhead=n_heads, batch_first=True
        )
        self.decoder = nn.TransformerDecoder(decoder_layer, num_layers=num_layers)

        self.fc = nn.Linear(d_model, 1)

    def forward(self, src, tgt):
        src = self.input_proj(src)
        tgt = self.input_proj(tgt)

        encoded = self.encoder(src)
        decoded = self.decoder(tgt, encoded)

        out = self.fc(decoded)
        return out.squeeze(-1)


model = TransformerTS()
optimizer = torch.optim.Adam(model.parameters(), lr=1e-3)
criterion = nn.MSELoss()

for e in range(10):
    optimizer.zero_grad()
    tgt = X_t[:, -1:, :].repeat(1, forecast_len, 1)
    pred = model(X_t, tgt)
    loss = criterion(pred, Y_t.squeeze(-1))
    loss.backward()
    optimizer.step()
    print(f"Epoch {e+1}/10 | Loss = {loss.item():.4f}")

torch.save(model.state_dict(), "best_transformer.pth")

def rolling_backtest_transformer(data, model, seq_len=60, forecast_len=14):
    results = []
    total = len(data)
    model.eval()

    for pos in range(1000, total - forecast_len):
        window = data[pos-seq_len:pos]
        xb = torch.tensor(window).float().unsqueeze(0)
        dec = xb[:, -1:, :].repeat(1, forecast_len, 1)

        with torch.no_grad():
            preds = model(xb, dec).numpy().flatten()

        true_vals = data[pos:pos+forecast_len, 0]

        rmse = np.sqrt(np.mean((preds - true_vals)**2))
        mae = np.mean(np.abs(preds - true_vals))
        mape = np.mean(np.abs((preds - true_vals)/(true_vals + 1e-6))) * 100

        results.append([pos, rmse, mae, mape])

    return pd.DataFrame(results, columns=["pos", "rmse", "mae", "mape"])

bt_tf = rolling_backtest_transformer(scaled, model)
bt_tf.to_csv("backtest_transformer.csv", index=False)

def rolling_backtest_sarimax(df, forecast_len=14):
    results = []
    values = df["value_0"].values

    for pos in range(1000, len(values) - forecast_len):
        train = values[:pos]
        m = SARIMAX(train, order=(2,1,2), seasonal_order=(1,1,1,7)).fit(disp=False)
        pred = m.forecast(forecast_len)
        true = values[pos:pos+forecast_len]

        rmse = np.sqrt(np.mean((pred - true)**2))
        mae = np.mean(np.abs(pred - true))
        mape = np.mean(np.abs((pred - true)/(true+1e-6))) * 100

        results.append([pos, rmse, mae, mape])

    return pd.DataFrame(results, columns=["pos", "rmse", "mae", "mape"])

bt_sarimax = rolling_backtest_sarimax(df)
bt_sarimax.to_csv("backtest_sarimax.csv", index=False)

summary = pd.DataFrame({
    "Model": ["Transformer", "SARIMAX"],
    "RMSE": [bt_tf["rmse"].mean(), bt_sarimax["rmse"].mean()],
    "MAE": [bt_tf["mae"].mean(), bt_sarimax["mae"].mean()],
    "MAPE": [bt_tf["mape"].mean(), bt_sarimax["mape"].mean()],
})
summary.to_csv("summary_metrics.csv", index=False)

last_input = scaled[-seq_len:]
x_last = torch.tensor(last_input).float().unsqueeze(0)
decoder = x_last[:, -1:, :].repeat(1, forecast_len, 1)

with torch.no_grad():
    pred_scaled = model(x_last, decoder).numpy().flatten()

final_preds = []
target_idx = features.index("value_0")

for p in pred_scaled:
    row = scaled[-1].copy()
    row[target_idx] = p
    inv = scaler.inverse_transform([row])[0][target_idx]
    final_preds.append(inv)

pd.DataFrame(final_preds, columns=["forecast"]).to_csv("final_forecast.csv", index=False)

def run_app():
    st.title("ðŸ“ˆ Advanced Time Series Forecasting (Transformer + Attention + SARIMAX)")

    st.subheader("Final 14-Day Forecast (Transformer Model)")
    st.write(final_preds)

    st.line_chart(final_preds)

    st.subheader("Model Comparison Summary")
    st.write(summary)

    st.subheader("Upload Custom CSV for Forecasting (Optional)")
    file = st.file_uploader("Upload CSV", type=["csv"])

    if file:
        user_df = pd.read_csv(file)
        st.write("Uploaded Data:", user_df.head())

    st.success("App Loaded Successfully!")


# Run Streamlit if chosen
if __name__ == "__main__":
    import sys
    if "streamlit" in sys.argv[0]:
        run_app()
    else:
        print("\nTraining + Backtest + Forecast Completed!")
        print("Run app using:")
        print("ðŸ‘‰ streamlit run main.py")